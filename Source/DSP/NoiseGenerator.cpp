#include "NoiseGenerator.h"
#include <cstdlib>
#include <cmath>

NoiseGenerator::NoiseGenerator()
{
}

void NoiseGenerator::setSampleRate(double newSampleRate)
{
    sampleRate = newSampleRate;
}

void NoiseGenerator::setNoiseType(NoiseType type)
{
    noiseType = type;
}

void NoiseGenerator::reset()
{
    // Reset pink noise state
    pinkState0 = 0.0f;
    pinkState1 = 0.0f;
    pinkState2 = 0.0f;
    pinkState3 = 0.0f;
    pinkState4 = 0.0f;
    pinkState5 = 0.0f;
    pinkState6 = 0.0f;

    // Reset brown noise state
    brownState = 0.0f;
}

float NoiseGenerator::processSample()
{
    switch (noiseType)
    {
        case NoiseType::White:
            return generateWhite();

        case NoiseType::Pink:
            return generatePink();

        case NoiseType::Brown:
            return generateBrown();

        default:
            return 0.0f;
    }
}

// ============================================================================
// Noise Generators
// ============================================================================

float NoiseGenerator::generateWhite()
{
    // White noise: equal energy per frequency
    // Simple random values in range [-1, +1]
    return randomFloat();
}

float NoiseGenerator::generatePink()
{
    // Pink noise generator using Paul Kellett's algorithm
    // This creates 1/f noise by summing multiple octaves of white noise
    // with different update rates
    //
    // Reference: http://www.firstpr.com.au/dsp/pink-noise/

    float white = randomFloat();

    // Update running sums at different rates (powers of 2)
    pinkState0 = 0.99886f * pinkState0 + white * 0.0555179f;
    pinkState1 = 0.99332f * pinkState1 + white * 0.0750759f;
    pinkState2 = 0.96900f * pinkState2 + white * 0.1538520f;
    pinkState3 = 0.86650f * pinkState3 + white * 0.3104856f;
    pinkState4 = 0.55000f * pinkState4 + white * 0.5329522f;
    pinkState5 = -0.7616f * pinkState5 - white * 0.0168980f;

    // Sum all octaves
    float pink = pinkState0 + pinkState1 + pinkState2 + pinkState3 + pinkState4 + pinkState5 + pinkState6 + white * 0.5362f;

    // Scale to approximately [-1, +1]
    pink *= 0.11f;

    pinkState6 = white * 0.115926f;

    return pink;
}

float NoiseGenerator::generateBrown()
{
    // Brown noise (Brownian noise): 1/fÂ² spectrum
    // Generated by integrating white noise (simple low-pass filter)
    // Also called "red noise" or "random walk noise"

    float white = randomFloat();

    // Integrate white noise with leaky integrator to prevent DC drift
    // The 0.02 term adds the new sample
    // The 0.998 term provides the integration (low-pass filtering)
    brownState = (brownState + white * 0.02f) * 0.998f;

    // Clamp to prevent overflow from accumulation
    if (brownState > 1.0f) brownState = 1.0f;
    if (brownState < -1.0f) brownState = -1.0f;

    // Scale for better output level
    return brownState * 3.5f;
}

float NoiseGenerator::randomFloat()
{
    // Generate random float in range [-1, +1]
    return (static_cast<float>(std::rand()) / RAND_MAX) * 2.0f - 1.0f;
}
